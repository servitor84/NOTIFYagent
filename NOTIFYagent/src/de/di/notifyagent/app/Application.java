package de.di.notifyagent.app;

import de.di.dokinform.license.ELOLicenseChecker;
import de.di.dokinform.util.ProductInfo;
import de.di.dokinform.util.Registry;
import de.di.license.check.LicenseException;
import de.di.license.check.LicenseKey;
import elo.di.notifyagent.elo.ELOClient;
import de.di.notifyagent.jobs.SchedulableFactory;
import de.di.notifyagent.profiles.Profile;
import de.di.notifyagent.profiles.ProfileException;
import de.di.notifyagent.profiles.ProfileFilenameFilter;
import de.di.notifyagent.profiles.ProfileManager;
import de.elo.ix.client.EditInfoC;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.DailyRollingFileAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.spi.LoggingEvent;
// <editor-fold defaultstate="collapsed" desc="class-description">

/**
 *
 * @author A. Sopicki
 * @modified S. Cioaba
 */
//</editor-fold>
public class Application extends Thread {

    private static Logger logger = null;
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * Properties object holding the settings for the application (e.g. input
     * directory etc.).
     */
    //</editor-fold>
    private static Properties settings = new Properties();
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * The dispatcher checks the input directory for incoming files. If new
     * files are available they will be dispatched to the scheduler. The
     * dispatcher is a Singleton.
     */
    //</editor-fold>
    private Dispatcher dispatcher = null;
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * Flag inidcating that this thread is currnetly active/inactive.
     */
    //</editor-fold>
    private volatile boolean running = true;
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * Flag indicating that shutdown has been forced due to an error or
     * exception.
     */
    //</editor-fold>
    private volatile boolean forcedShutdown = false;
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * Buffer for logmessages generated by the start up sequence when writing to
     * the logfile is not possible yet.
     */
    //</editor-fold>
    private BufferHandler logHandler = null;
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * Handler for writing logmessages to the log file.
     */
    //</editor-fold>
    private DailyRollingFileAppender handler = null;
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * Shutdown hook to initiate a clean shutdown if the VM is terminated by
     * some event (e.g. the process is killed).
     */
    //</editor-fold>
    private ShutdownHandler shutdownHandler = null;
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * InputStream of the config file. It is either set by the constructor or
     * will be set during start up.
     */
    //</editor-fold>
    private InputStream configStream = null;
    private InputStream licenseStream = null;
    private File profileDir = null;
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * The status of the application. The data will be read from different
     * sources to dislplay it where appropriate
     */
    //</editor-fold>
    private java.util.Map<String, String> status = new java.util.HashMap<String, String>();
    // <editor-fold defaultstate="collapsed" desc="documentation">   
    /**
     * Error information if startup failed due to an exception
     */
    //</editor-fold>
    private java.util.List<String> errorStatus = new java.util.ArrayList<String>();
    private ELOClient eloClient;
    private ProfileManager profileManager;
    private boolean oneTimePass = true;

    private int maxAbonnements = 0, loginErrorCount = 0;        

    // +++
    private java.util.Map<String, String> mode = new java.util.HashMap<String, String>();
    
    // <editor-fold defaultstate="collapsed" desc="constructor-documentation">  
    /**
     * Constructor for application start up from the command line. It will use
     * null as the input stream for the config file. The application will set
     * the input stream in the start up sequence.
     */
    //</editor-fold>
    public Application() {
        this(null);
    }

    // <editor-fold defaultstate="collapsed" desc="initLogger-documentation">  
    //</editor-fold>   
    private void initLogger() {
        BasicConfigurator.configure();
        logger = Logger.getLogger(this.getClass().getPackage().getName());
        logHandler = new BufferHandler();
        logger.addAppender(logHandler);
        logger.setLevel(Level.ALL);
    }

    //<editor-fold defaultstate="collapsed" desc="init-application-files">
    /**
     * @param configURL Url for the conf folder from the webApplication
     */
    //</editor-fold>
    private void initApplicationFiles(java.net.URL configURL) throws URISyntaxException, FileNotFoundException, MalformedURLException {
        if (configURL == null) {
            configURL = new File("conf/").toURI().toURL();
        }
        File configDirectory = new File(configURL.toURI());
        if (configDirectory.exists()) {
            configStream = new FileInputStream(new File(configDirectory, "config.properties"));
            licenseStream = new FileInputStream(new File(configDirectory, "license.txt"));
            profileDir = new File(configDirectory.getParentFile(), "profiles");
        } else {
            logger.error("No conf directory found. Please configure the product carefully");
        }

    }

    //<editor-fold defaultstate="collapsed" desc="main-Constructor-documentation">
    /**
     * @param configURL Url for the conf folder from the webApplication The
     * constructor if it has any problems it will not continue
     */
    //</editor-fold>
    public Application(java.net.URL configURL) {
        try {
            initLogger();
            initApplicationFiles(configURL);
            loadSettings();
            loadProductInfo();
        } catch (Exception ex) {
            if (logger != null) {
                logger.error(ex, ex);
            }
            running = false;
        }
    }

    //<editor-fold defaultstate="collapsed" desc="run-documentation">
    //</editor-fold>
    @Override
    public void run() {

        logger.info("Starting " + status.get("product") + " (Version: " + status.get("version") + ")");
        startUp();
        if (running == false) {
            logger.trace(getClass().getName() + ": run()");
            if (handler == null) {
                for (LoggingEvent evt : logHandler.getEvents()) {
                    errorStatus.add(evt.getRenderedMessage());
                }
            }
            return;
        }
        shutdownHandler = new ShutdownHandler();
        Runtime.getRuntime().addShutdownHook(shutdownHandler);
        logger.info("Startup complete");
        logger.info("Entering main loop");
        while (running) {
            try {
                if (oneTimePass) {
                    dispatcher.join();
                    running = false;                    
                } else {
                    Thread.sleep(500);
                }
            } catch (Exception e) {
                logger.fatal("Unhandled exception occured! Please report the bug if possible with all information available to reproduce the problem. ");
                logger.error(e, e);
            }
            if (running) {
                try {
                    if (!dispatcher.isAlive()) {
                        forceShutdown();
                    }
                } catch (NullPointerException npe) {
                    logger.error("Error on shutdown");
                }
            }
        }
        if (!forcedShutdown) {
            if (logger != null) {
                logger.debug("Leaving main loop");
            }            
            try {
                if (dispatcher != null) {
                    dispatcher.shutdown();
                    dispatcher.join(5000);
                }
            } catch (Exception e) {
                logger.error(e, e);
            } finally {
                dispatcher = null;
            }
            settings = null;
        }
        if (eloClient != null) {
            eloClient.logoff();
            eloClient = null;
        }
        MultiThreadedHttpConnectionManager.shutdownAll();
        if (handler != null) {
            if (logger != null) {
                logger.removeAppender(handler);
            }
            handler.close();
            handler = null;
        }
        logger = null;
        Registry.getInstance().clear();
    }

    public void shutdown() {
        if (running == false) {
            return;
        }
        if (logger != null) {
            logger.info("Shutting down...");
        }

        running = false;

        interrupt();
    }

    /**
     * Force an immediate shutdown of the application.
     */
    public void forceShutdown() {
        logger.fatal("Forcing shutdown");
        forcedShutdown = true;
        if (dispatcher != null) {
            dispatcher.shutdown();
            dispatcher = null;
        }
        try {
            if (shutdownHandler != null) {
                Runtime.getRuntime().removeShutdownHook(shutdownHandler);
            }
        } catch (IllegalStateException ise) {
        }
        shutdownHandler = null;
        settings = null;
        running = false;
        interrupt();
    }

    /**
     * Callback function for the status page to get some status information from
     * the running application.
     *
     * Currently the following information is available:
     *
     * Key: version, the version of the application Key: product_name, the
     * product name of the application Key: queue_size, the size of the queue
     * for incoming files Key: scheduler_status, status of the scheduler (true
     * if it is running, false otherwise) Key: queue_count, files currently
     * processed (only if scheduler is running!) Key: worker_count, number of
     * workers available (only if scheduler is running!) Key: dispatcher_status,
     * status of the dispatcher (true if it is running, false otherwise) Key:
     * active_job_count, number of open files (only if dispatcher is running!)
     *
     * @return java.util.Map<String, String> a map holding the status
     * information
     */
    public synchronized java.util.Map<String, String> getStatus() {
        if (dispatcher != null && dispatcher.isAlive()) {
            status.put("dispatcher_status", "true");
            status.put("dispatcher_state", dispatcher.getProcessingState().toString());
        } else {
            status.put("dispatcher_status", "false");
        }
        return status;
    }    
   
    // SL - for the access to the settings file from the jsp file
    public static Properties getSettings() {
        return settings;
    }

    public HashMap<String, String> getProfileList() {
        HashMap<String, String> profiles = new HashMap<String, String>();

        for (Profile p : profileManager.getProfiles()) {
            int lastIndex = p.getClass().getSimpleName().lastIndexOf(".");
            profiles.put(p.getProfileName(), p.getClass().getSimpleName().substring(lastIndex != -1 ? lastIndex : 0));
        }

        return profiles;
    }
    
    // SL - third column for sendimmadiately property
    public String[] getTests() {
        String[] tests = new String[getProfileList().size()];
        int i = 0;
        for(Profile p : profileManager.getProfiles()) {
            tests[i] = p.getTest();
            i++;
        }
        return tests;
    }

    public synchronized java.util.List<String> getErrorStatus() {
        return errorStatus;
    }

    private void loadProductInfo() {
//        logger.fatal("de/arivato/notifyagent/app/resources/product.properties");
        String productName = "";
        if (settings.getProperty("Basic.ServiceName").startsWith("cm-") || settings.getProperty("Basic.ServiceName").toUpperCase().startsWith("CONTRACT")) {
            productName = "CONTRACTmanager";
        } else {
            productName = "NOTIFYagent";
        }
//        logger.fatal("de/arivato/notifyagent/app/resources/product_" + productName + ".properties");
        InputStream in = getContextClassLoader().getResourceAsStream("de/di/notifyagent/app/resources/product_" + productName + ".properties");
//        logger.fatal("de/arivato/notifyagent/app/resources/product_" + productName + ".properties");

        if (in != null) {
            ProductInfo.readProductInfo(in, status);         
        }
    }
    
    // +++    
    public java.util.List<String> loadSendImmediatelyValues()
    {
        File[] profileFiles = profileDir.listFiles(new ProfileFilenameFilter());
        java.util.List<String> sendImmediately = new ArrayList<String>();        
        for (File profileFile : profileFiles) {
            try {
                Properties props = new Properties();
                FileInputStream inputStream = null;
                try {
                    inputStream = new FileInputStream(profileFile);
                    props.load(inputStream);                    
                } catch (IOException ioex) {
                    this.logger.debug("An exception occured while loading profile " + profileFile.getName(), ioex);
                    throw new ProfileException("Unable to load profile " + profileFile.getName());
                } finally {
                    try {
                        inputStream.close();
                    } catch (Exception ex) {
                    }
                }
                sendImmediately.add(props.getProperty("SendImmediately", ""));                
            } catch (Exception ex) {
                logger.warn("Error ocured in profile file: " + profileFile.getName());
                logger.warn(ex);
            }
        }
        return sendImmediately;
    }
    
    public java.util.HashMap<String, String> getMode()
    {
        File[] profileFiles = profileDir.listFiles(new ProfileFilenameFilter());
        java.util.HashMap<String, String> modes = new HashMap<String, String>();
        for (File profileFile : profileFiles) {
            try {
                Properties props = new Properties();
                FileInputStream inputStream = null;
                try {
                    inputStream = new FileInputStream(profileFile);
                    props.load(inputStream);                    
                } catch (IOException ioex) {
                    this.logger.debug("An exception occured while loading profile " + profileFile.getName(), ioex);
                    throw new ProfileException("Unable to load profile " + profileFile.getName());
                } finally {
                    try {
                        inputStream.close();
                    } catch (Exception ex) {
                    }
                }
                modes.put(props.getProperty("ProfileName", ""), props.getProperty("SendImmediately", ""));                
            } catch (Exception ex) {
                logger.warn("Error ocured in profile file: " + profileFile.getName());
                logger.warn(ex);
            }
        }
        return modes;
    }
    
    // +++

    private void startUp() {
        logger.info(getClass().getName() + ": entering startUp()");
        try {
            boolean newInstall = Boolean.parseBoolean(settings.getProperty("Basic.NewInstall", "TRUE"));
            if (newInstall) {
                logger.fatal("Service is currently deactivated. Aborting.");
                throw new StartUpException("Service is currently deactivated.  ");
            }
            checkDirectories();
            startLogging();
            checkSettings();
            initELOClient();
            loadProfiles();
//            loadSubscriptions();
            logger.debug("before license");
            checkLicense(profileManager.getProfileCount());
            logger.debug("After license");
            SchedulableFactory fac = new SchedulableFactory(settings, eloClient);
            logger.debug("After factory");
            dispatcher = new Dispatcher(settings, fac, profileManager);
            dispatcher.start();            
            logger.debug("After startup");
        } catch (StartUpException sex) {
            logger.debug("An exception occured on startup " + sex.getMessage()); // befor: logger.debug("An exception occured on startup", sex);
            logger.info("Unable to start the service.");
            if (dispatcher != null) {
                dispatcher.shutdown();
            }
            running = false;
        } catch (ApplicationException aex) {
            logger.debug("An exception occured on startup", aex);
            logger.info("Unable to start the service.");
            if (dispatcher != null) {
                dispatcher.shutdown();
            }
            running = false;
        }
        logger.trace(getClass().getName() + ": leaving startUp()");
    }

    /**
     * Loads the properties from the configStream.
     *
     * @throws de.arivato.erpconnect.ERPConnect.StartUpException
     */
    private void loadSettings() throws StartUpException {
        logger.trace(getClass().getName() + ": loadSettings() start.");
        try {
            settings.load(configStream);
            configStream.close();
        } catch (java.io.IOException ioex) {
            logger.fatal("Unable to read config file 'config.properties'.", ioex);
            throw new StartUpException();
        }
        Registry.getInstance().put("settings", settings);
        logger.trace(getClass().getName() + ": loadSettings() end.");
    }

    /**
     * Start logging to the log file
     *
     * @throws de.arivato.erpconnect.ERPConnect.StartUpException
     */
    private void startLogging() throws StartUpException {
        logger.trace(getClass().getName() + ": entering logging()");
        File logDir = null;

        try {
            logDir = new File(settings.getProperty("Directories.Logging"));
        } catch (NullPointerException nex) {
            logger.log(Level.FATAL, "Logging directory not found!");
            throw new StartUpException();
        }

        if (logDir.canWrite() == false) {
            logger.log(Level.FATAL, "Unable to write to log directory");
            throw new StartUpException();
        }

        String logfile;

        try {
            logfile = logDir.getCanonicalPath() + File.separator + settings.getProperty("Basic.ServiceName").toLowerCase() + ".log";
            handler = new DailyRollingFileAppender();
            handler.setDatePattern("'.'yyyy-MM-dd");
            handler.setFile(logfile);
            handler.setImmediateFlush(true);
            handler.setName("NOTIFYagentAppender");

            String pattern = settings.getProperty("Basic.LoggingPattern",
                    "%d{dd.MM.yyyy HH:mm:ss} %-5p [%t]: %m%n");
            handler.setLayout(new PatternLayout(pattern));
            handler.activateOptions();

            Level logLevel = Level.toLevel(settings.getProperty("Basic.LogLevel", "WARN"), Level.WARN);

            Logger baseLogger = Logger.getLogger("de.di");
            baseLogger.addAppender(this.handler);
            baseLogger.setLevel(logLevel);

            baseLogger = Logger.getLogger("org.apache.commons");
            baseLogger.setLevel(Level.WARN);

            for (LoggingEvent event : this.logHandler.getEvents()) {
                if (event.getLevel().isGreaterOrEqual(logLevel)) {
                    this.handler.append(event);
                }
            }

            logger.setLevel(logLevel);
            this.logHandler.close();

        } catch (java.io.IOException ioex) {
            logger.log(Level.FATAL, "Unable to create log file");
            throw new StartUpException();
        } catch (IllegalArgumentException iaex) {
            logger.log(Level.FATAL, "Illegal log level set");
            throw new StartUpException();
        }

        logger.trace(getClass().getName() + ": leaving logging()");
    }

    /**
     * Checks the directories for read and write access.
     *
     * @throws de.arivato.erpconnect.ERPConnect.StartUpException
     */
    private void checkDirectories() throws StartUpException {
        logger.trace(getClass().getName() + ": entering checkDirectories()");

        File dir = new File(settings.getProperty("Directories.Logging", ""));

        if (!dir.canWrite()) {
            logger.fatal("Logging directory not configured or not writable!\n"
                    + "Please edit config.properties accordingly or \nmake the "
                    + " directory writeable for the application.");
            throw new StartUpException();
        }

        dir = new File(settings.getProperty("Directories.MailQueue", ""));

        if (!dir.canWrite()) {
            logger.fatal("Mailqueue directory not configured or not writable!\n"
                    + "Please edit config.properties accordingly or \nmake the "
                    + " directory writeable for the application.");
            throw new StartUpException();
        }

        logger.trace(getClass().getName() + ": leaving checkDirectories()");
    }

    /**
     * Method making some basic settings checks for consistency (e.g.
     * Index.TemplateFile doesn't point to non-existing file).
     *
     * @throws de.arivato.erpconnect.ERPConnect.StartUpException
     */
    private void checkSettings() throws StartUpException {
        logger.trace(getClass().getName() + ": entering checkSettings()");

        if (settings.getProperty("IndexServer.URL", "").length() == 0) {
            throw new StartUpException("URL for the index server not set!");
        }

        if (settings.getProperty("IndexServer.Password", "").length() == 0) {
            throw new StartUpException("Password for the index server not set!");
        }

        if (settings.getProperty("IndexServer.User", "").length() == 0) {
            throw new StartUpException("User for the index server not set!");
        }

        if (settings.getProperty("MailQueue.SignalFileExtension", "").length() == 0) {
            throw new StartUpException("Signalfile extension not set for the mail queue!");
        }

        if (settings.getProperty("Application.InsertJavaclientURL", "").length() == 0) {
            throw new StartUpException("Missing Application.InsertJavaclientURL config parameter");
        }
        if (settings.getProperty("Application.Groupname", "").length() == 0) {
            throw new StartUpException("Missing Application.Groupname config parameter");
        }

        logger.trace(getClass().getName() + ": leaving checkSettings()");
    }

    private void initELOClient() throws StartUpException {
        logger.trace(getClass().getName() + ": entering initELOClient()");

        String ix = settings.getProperty("IndexServer.URL");
        String user = settings.getProperty("IndexServer.User");
        String password = settings.getProperty("IndexServer.Password");
        // PWD decription +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        String pattern = "^((\\d){1,})([-]{1}(\\d){1,}){1,}";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher matcher = p.matcher(password);
        if(matcher.matches()) {
            try {
                de.elo.utils.sec.DesEncryption des = new de.elo.utils.sec.DesEncryption();
                password = des.decrypt(password);
            } catch (Exception ex) {
                logger.error("Fehler bei der Entschlüßelung des Passwortes: " + ex);
            }            
        }
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++SL 17.03.2020

        eloClient = new ELOClient();                
        eloClient.setConnectionUrl(ix);
        eloClient.setUserName(user);
        eloClient.setPassword(password);
        logger.info("Trying to connect. URL: " + ix + " ,user:" + user + " ,password: ****");
        int retryCount = 10000;

        while (!eloClient.isConnected() && retryCount > 0) {
            logger.debug("Is entering login loop");
            try {                         
                eloClient.login();                               
            } catch (de.elo.utils.net.RemoteException ex) { //login failed
                retryCount--;
                for (StackTraceElement elem : ex.getStackTrace()) {
                    logger.trace(elem.getFileName() + ":" + elem.getLineNumber() + " "
                            + elem.getClassName() + "." + elem.getMethodName());
                }
                logger.debug("An exception occured while connecting to the index server.");
                logger.warn("Connection to index server failed: ");

                try {
                    Thread.sleep(5000); //wait 5s for next try
                } catch (InterruptedException ex1) {
                }
            } catch (IllegalStateException stateex) {
                retryCount--;
                logger.debug("An exception occured while connecting to the index server.");
                logger.warn("Connection to index server failed: ");

                try {
                    Thread.sleep(5000); //wait 5s for next try
                } catch (InterruptedException ex1) {
                }
            }
        }
        // ELOixIsReachable(eloClient);
        
        if (retryCount == 0) {
            throw new StartUpException("Connection to index server currently unavailable. Shutting down.");
        }        
        logger.trace(getClass().getName() + ": leaving initELOClient()");
    }

    private void loadProfiles() throws StartUpException {
        logger.trace(getClass().getName() + ": entering loadProfiles()");

        profileManager = new ProfileManager(eloClient);
        if (profileDir == null || !profileDir.exists()) {
            throw new StartUpException("No profiles folder available.Please check it's existence");
        }
        profileManager.loadProfiles(profileDir);
        logger.trace(getClass().getName() + ": leaving loadProfiles()");
    }

    private void checkLicense(int profileCount)
            throws StartUpException {
        logger.trace(getClass().getName() + ": entering checkLicense()");
        int maxProfiles = 0;

        try {
            ELOLicenseChecker checker = new ELOLicenseChecker(status.get("product"));
            checker.setSettings(settings);
            LicenseKey key;

            if (licenseStream != null) {
                key = LicenseKey.readFromFile(licenseStream);
                licenseStream.close();
            } else {
                key = LicenseKey.readFromFile(new File("conf/license.txt"));
            }

            checker.check(key, checker.getRounds()); //

            status.put("client", key.getAttribute("client").getValue());
            status.put("ELO_version", key.getAttribute("ELO-version").getValue());
            status.put("ERP_system", key.getAttribute("ERP-system").getValue());
            status.put("license_type", key.getAttribute("license-type").getValue());
            status.put("expiration_date", java.text.DateFormat.getDateInstance().format(key.getExpirationDate()));
            status.put("license_key", key.getAttribute("bytes2").getValue());
            
            

            checker = null;

            Pattern pattern = Pattern.compile("^(\\d+)\\s.*");
            Matcher matcher = pattern.matcher(key.getAttribute("license-type").getValue());
            String profiles = "0";

            if (matcher.matches()) {
                profiles = matcher.group(1);
            }

            try {
                maxProfiles = Integer.parseInt(profiles);
            } catch (NumberFormatException nfe) {
            }

            if (profileCount > maxProfiles) {
                throw new LicenseException("Profile count exceeded. Only " + maxProfiles
                        + " profiles allowed");
            }

            status.put("profileCount", Integer.toString(profileCount));
            status.put("maxProfiles", Integer.toString(maxProfiles));

            logger.info("Profile count: " + profileCount + " Max: " + maxProfiles);
        } catch (LicenseException lex) {
            logger.fatal("License violation detected: " + lex.getMessage());
            throw new StartUpException();
        } catch (java.io.IOException ioex) {
            logger.fatal("License check file corrupted", ioex);
            throw new StartUpException();
        } catch (java.security.NoSuchAlgorithmException ex) {
            logger.fatal("License check not possible");
            throw new StartUpException();
        }
        logger.trace(getClass().getName() + ": leaving checkLicense()");
    }

    /**
     * Inner class implementing the shutdown hook for the VM.
     */
    private class ShutdownHandler extends Thread {

        @Override
        public void run() {
            shutdown();
            try {
                try {
                    Application.this.join();
                } catch (Exception e) {
                }

                //handler.flush();
            } catch (Exception e) {
            }
        }
    }

    /**
     * Inner class for an exception during start up sequence.
     */
    private class StartUpException extends Exception {

        StartUpException() {
            super();
        }

        StartUpException(String msg) {
            super(msg);
        }
    }

    /**
     * Handler for buffering log records durin start up.
     */
    private class BufferHandler extends org.apache.log4j.AppenderSkeleton {

        private ArrayList<LoggingEvent> events = new ArrayList<LoggingEvent>(30);

        BufferHandler() {
            super();
            super.setName(getClass().getName());
        }

        @Override
        protected void append(LoggingEvent event) {
            events.add(event);
        }

        @Override
        public void close() {
        }

        @Override
        public boolean requiresLayout() {
            return false;
        }

        public java.util.List<LoggingEvent> getEvents() {
            return events;
        }
    }        
    

    public static void main(String[] args) throws RemoteException, de.elo.utils.net.RemoteException {
        ELOClient temp = new ELOClient();
        temp.setConnectionUrl("http://arivato-pc5:9090/ix-Test/ix");
        temp.setUserName("Administrator");
        temp.setPassword("elo");
        temp.login();
        System.out.println(temp.getSord("1", EditInfoC.mbAll).getGuid());
    }
}
